# Integrating TDD and Modern Patterns into Campfire’s Architecture & Steering Docs

## TDD-Driven Architecture: Plan Before You Code

A key enhancement for the **architecture** and **architecture-L2** documents is to adopt a **Test-Driven Development (TDD)** philosophy that emphasizes **designing upfront**. Before writing any implementation code, the team should **“hash out” the system design by defining all critical function signatures, module APIs, and interactions**. This one-shot upfront design (inspired by *“One‑Shot Correct Campfire Rewrite (TDD-Driven Architecture)”*) means thinking through how each function or component will be used (its inputs/outputs) **before** writing its body.

In practice, this entails writing tests and interface stubs first. For example, you might begin by writing a unit test that calls a not-yet-implemented function with certain parameters and asserts an expected result. Doing so forces you to decide **what that function’s signature should look like and what it should return** to satisfy the test[\[1\]](https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined#:~:text=TDD)[\[2\]](https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined#:~:text=It%27s%20true%20that%20in%20order,sense%2C%20conceptual%20design%20%27comes%20first). *In other words, writing tests first helps in planning the application’s architecture by defining desired behaviors and interfaces upfront[\[3\]](https://github.com/luizalabs/tutorial-python-brasil/blob/ce1959d57de1352ef2763ab26ec340b612196058/tdd.md#L43-L50).* This approach treats tests as a **design tool**: “writing the test before the actual implementation forces you to ask the question: *What do I expect from the code?*”[\[4\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=In%20this%20approach%2C%20we%20start,I%20expect%20from%20the%20code). By answering that, you clarify the function’s purpose and contract before coding its internals.

To integrate this into the **architecture docs**, consider adding a section on **TDD Approach** under architecture principles. This section can outline steps like:

* **Define module responsibilities and public APIs first** – List the functions, classes (if any), and data structures each module will expose. For each, capture its purpose, inputs, outputs, and errors. Essentially, create a skeletal outline of the code’s interface.

* **Write high-level tests for each requirement** – Ensure every requirement in the requirements.md is addressed by one or more tests. Use these tests as “executable specifications” of the system’s behavior. *Writing tests first not only verifies behaviors (not implementation details) but also yields living documentation of how modules should work[\[4\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=In%20this%20approach%2C%20we%20start,I%20expect%20from%20the%20code)[\[5\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=The%20requirements%20may%20be%20something,like).*

* **Implement in** small TDD cycles *– Emphasize that coding should follow the red-green-refactor cycle for each small piece of functionality. For instance, write just enough test to require one function or case, then write the minimal code (often just the function signature and a stub return) to get the test to compile and fail, then implement to make it pass, and refactor. As one experienced developer advises: “You don’t need to write the whole test first… write the smallest* possible part, then make it green (write the signature, for example), then refactor\! Repeat until you have a working feature. That’s how TDD goes.”[\[6\]](https://www.reddit.com/r/golang/comments/17ubh56/tdd_i_keep_doing_implementation_first_rather/#:~:text=You%20don%27t%20need%20to%20write,That%27s%20how%20TDD%20goes) This encourages incremental design refinement while ensuring you thought through each function’s role beforehand.

By incorporating these ideas, the **architecture-L2 document** (which likely contains more detailed designs and maybe pseudo-code) can be expanded to include the planned function signatures and module interfaces derived through TDD. For example, architecture-L2 could present a breakdown of each subsystem with the list of functions/API endpoints it provides, alongside brief descriptions or preconditions/postconditions. Essentially, **architecture-L2 becomes a blueprint of the code’s structure defined purely by its interfaces and contracts**, without yet delving into algorithmic implementation. This level of detail ensures that by the time coding starts, the team has a clear map of *what* needs to be built and *how* pieces will interact, minimizing surprises during implementation. It aligns with the idea of getting the “one-shot” design as correct as possible upfront, using tests as a guide. (Of course, TDD is iterative by nature[\[7\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=TDD%20is%20an%20iterative%20approach,adapting%20itself%20to%20its%20tests), so the docs should acknowledge that interfaces might evolve slightly as we discover new insights from writing tests, but the goal is to converge quickly with minimal redesign.)

## Integrating TDD Philosophy into Steering Documents

The **steering documents** (which guide project methodology and high-level technical direction) should explicitly incorporate this TDD-focused philosophy. This ensures everyone is on the same page about *how* we approach development. Key points to update in the steering docs:

* **Development process**: State that all new features or modules will be developed using TDD. For example, the steering doc can mandate: *“For each new feature, write the unit tests and function signatures* *before* *implementing the feature’s logic.”* This sets a clear expectation and cultural norm. It might also mention using tools or CI checks to encourage this (e.g. requiring test stubs or designs before PRs). Emphasize that writing tests first will drive a cleaner design and help avoid over-engineering. As noted in the architecture updates, tests serve as a specification – the steering doc can highlight that *tests will act as the primary documentation of behavior*, so developers should use them to understand module usage and expected outcomes[\[4\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=In%20this%20approach%2C%20we%20start,I%20expect%20from%20the%20code).

* **Design reviews**: Update the steering guidelines to include design review steps where team members review proposed function signatures and test cases *before* implementation. This is in line with “hashing out everything” upfront. By reviewing the planned interfaces and test coverage early, the team can catch design issues when they are easier to fix (before code is written).

* **One-shot correct mentality**: Explain in the steering doc the rationale of aiming for a “one-shot” correct implementation by thorough planning. This doesn’t mean no iteration, but that we try to avoid big architectural refactors later by spending more effort designing now. It’s essentially a lightweight form of *specification-driven development* using TDD. The steering doc can draw a contrast: rather than trial-and-error coding, we “design twice, code once” – first on paper (or in docs/tests), then in the IDE. This approach improves confidence that when we do write code, it will fit together well and meet requirements with minimal rework. (It also aligns with quality goals: fewer bugs and a more thoughtful architecture from the outset.)

In summary, the steering document becomes a place that **enforces the discipline of TDD and upfront design**. New sections or guidelines should make it clear that: (a) writing tests and planning interfaces comes first, (b) implementation is guided by those tests, and (c) this approach is expected for all contributors. This shared philosophy in the steering doc will ensure the architecture and design principles are actually followed during development.

## Incorporating Modern Rust and React Patterns into the Docs

We also want to update the steering (and related design/architecture docs) with the **best and most relevant Rust and React patterns** from the provided references. This will ensure our project leverages proven practices and avoids known pitfalls in both the backend (Rust) and frontend (React). Below, we integrate key patterns and anti-pattern avoidances for each:

### Rust Patterns and Best Practices

Campfire’s backend being in Rust means we should embrace Rust’s idioms and modern design patterns. The steering/architecture docs should be updated to reflect guidelines such as:

* **Idiomatic Error Handling**: Make error handling a first-class part of the design. Functions should return Result\<T, E\> or Option\<T\> rather than panicking. *Avoid anti-patterns like using unwrap() or expect() in production code*, as they can crash the program and obscure error contexts[\[8\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Anti,Addiction)[\[9\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Rust%E2%80%99s%20promise%20of%20performance%20and,to%20unlock%20Rust%E2%80%99s%20full%20potential). Instead, propagate errors with ? or use graceful handling. For example, our architecture docs can specify that any I/O or fallible operations are designed to bubble up errors to a centralized handler (perhaps logging or converting to user-friendly messages). The Rust patterns reference suggests using libraries like anyhow or thiserror to simplify error management[\[10\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Takeaway%3A%20Embrace%20,simplify%20error%20handling). Steering docs should thus encourage using those utilities and documenting errors in function signatures.

* **Ownership and Borrowing over Cloning**: Emphasize patterns that leverage Rust’s ownership model for efficiency. *Excessive cloning is a common anti-pattern* that hurts performance and can indicate suboptimal ownership designs[\[9\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Rust%E2%80%99s%20promise%20of%20performance%20and,to%20unlock%20Rust%E2%80%99s%20full%20potential). Our design should try to transfer ownership or use references (\&T or smart pointers like Arc\<T\> for shared ownership) rather than cloning large data structures unnecessarily. The steering doc can include a guideline like: “Avoid clone() in hot code paths or loops; prefer borrowing. Only clone when ownership semantics require it, and document why.” This keeps the project performant and memory-efficient.

* **Concurrency and Async**: If Campfire is a networked or multi-user system, we likely use async I/O. A modern Rust pattern is to use async/await for concurrency and **avoid blocking calls in async contexts**. The docs should note that any heavy CPU-bound work should be offloaded (e.g., to a separate thread via spawn\_blocking in Tokio) so as not to block the async executor[\[11\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=1.%20Handle%20CPU,spawn_blocking). Similarly, use of channels or message-passing (the actor model) can be encouraged for safe concurrency, instead of locking mutexes aggressively (which can lead to contention). The Rust guidance might include: “Prefer non-blocking designs and leverage Rust’s Send/Sync boundaries to ensure thread safety. Use channels for synchronization instead of sharing mutable state where possible.”

* **Trait-Based Abstractions**: Rust’s trait system enables powerful abstraction without the need for classic OOP inheritance. The architecture can adopt patterns like **Strategy via Traits** – define traits for behaviors and have multiple implementations. For example, if Campfire has different data storage backends, an Storage trait could define the interface, with implementations for, say, an in-memory store vs. a database. This aligns with the Strategy Pattern implemented idiomatically with traits[\[12\]](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba#:~:text=1)[\[13\]](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba#:~:text=When%20most%20people%20talk%20about,with%20something%20simpler%20and%20safer). The docs should recommend designing modules around traits and trait objects or generics for extendibility and testability (we can swap out implementations in tests). Rust’s enums and pattern matching are another powerful tool: for instance, using enums to represent state machines or command types can eliminate complex conditional logic and make code more self-documenting. Overall, state in the docs that *Rust’s features (traits, enums, pattern matching, ownership) often allow replacing classic patterns with simpler, safer designs[\[13\]](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba#:~:text=When%20most%20people%20talk%20about,with%20something%20simpler%20and%20safer)*. Our architecture should leverage these (e.g., use enums for variant behavior instead of a base class with many subclasses, use pattern matching instead of if-chains).

* **Memory Safety Patterns**: Include guidelines on using Rust’s safety to our advantage. For instance, ensure all unsafe code (if any) is encapsulated and justified in docs. Encourage use of RAII patterns (e.g., using Drop to release resources) and smart pointers as needed. Also, highlight using the type system to enforce invariants (e.g., newtype wrappers for IDs to avoid mixing them up, or opaque types to prevent misuse).

* **Performance and Profiling**: The steering doc can mention that writing idiomatic Rust often yields good performance, but developers should be mindful of common slowdowns. This ties back to avoiding anti-patterns: e.g., *don’t use a Vec when another structure is more appropriate for the access patterns*, don’t hold locks longer than necessary, etc. A note can be added: “We will profile critical code to ensure our patterns are efficient. In Rust 2025, writing **fast, robust code** means avoiding things like excessive cloning, blocking I/O in async, and recklessly unwrapping errors[\[9\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Rust%E2%80%99s%20promise%20of%20performance%20and,to%20unlock%20Rust%E2%80%99s%20full%20potential) – our codebase will reflect those best practices.”

By updating the docs with these Rust-specific guidelines, we steer the backend development to be idiomatic, reliable, and maintainable. New team members reading the steering/architecture docs should immediately grasp what *to do* (e.g. use Result for errors, break logic into small trait-bound functions) and what *not to do* (e.g. avoid global mutable state, avoid panics for flow control).

### React Patterns and Best Practices

For the front-end, the **steering and design docs** should incorporate modern React patterns (as of 2025\) and caution against anti-patterns, to ensure the client side of Campfire is equally well-architected and easy to maintain. Key points to include:

* **Functional Components with Hooks**: Update any references to class components — we should standardize on **function components** as the default, since they are now the de facto standard in React[\[14\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Function%20Components%20as%20the%20Standard). The docs can note that function components combined with Hooks provide a simpler and more composable way to build UI. State that **all new components** should be functional and use Hooks for state and side-effects (React 19+ has further solidified this approach). This simplifies our codebase and aligns with modern best practices.

* **Custom Hooks for Reusability**: Encourage breaking out complex logic into **custom hooks**. The steering or design guide can provide an example or template. For instance: if multiple components need to share behavior (like form handling, data fetching, etc.), create a hook (e.g., useFormInput or useFetch) to encapsulate that logic. *Custom hooks promote reuse and cleaner components by separating concerns[\[15\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Custom%20Hooks%20for%20Logic%20Reusability).* Our docs should list this as a preferred pattern: “If you find yourself copying logic between components, refactor it into a useXYZ hook and reuse it.” This keeps components lean and focused on presentation, aligning with separation of concerns.

* **Context for Global State (with Caution)**: The docs should mention the appropriate use of the React Context API. In modern React, Context has “matured into a reasonable solution for managing application-wide state”[\[16\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Context%20API%20for%20Application), reducing the need for external state libraries (like Redux) for many cases. We should outline when to use Context – for truly global or cross-cutting state (e.g., user authentication info, theme, maybe high-level app settings) – and when not to (don’t use Context to pass data that only a couple components need; prop drilling in those limited cases might be fine). The steering doc can advise: “Use Context to avoid excessive prop drilling for global concerns, but avoid overusing it for ephemeral state. Be mindful of performance (large context values can trigger re-renders).” We can pair this with guidance on structuring context providers hierarchically and using React’s optimization (like memoization or splitting context) to avoid context misuse.

* **State Management Patterns**: If Campfire’s frontend is non-trivial in state, we should document how we handle complex state. Perhaps we use a combination of React’s built-in hooks (useState, useReducer) and context. If the reference “Advanced React Patterns and Anti-Patterns” suggests alternatives (like Zustand or Redux Toolkit if needed), we can mention the chosen approach. For simplicity, likely the project sticks to React’s own tools given React 19 improvements. We should also mention using **Reducers** for complex state logic within a component or context (the pattern of useReducer to manage state transitions predictably).

* **Component Composition over Prop Drilling**: Reinforce a pattern of composition. For example, if we have a \<CampfireProvider\> context at top-level, nested components can consume context instead of threading props through many layers. Also, design components in a way that smaller components can be composed to create bigger UIs, rather than one monolithic component holding everything. *One common anti-pattern to avoid is “prop drilling” – passing props through numerous intermediate components that don’t need them[\[17\]](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933#:~:text=6%20Common%20React%20Anti,Complicated%20Logic%20in).* Our design doc should note that if a prop is passed down more than a couple levels, consider a different approach (context or restructure the component hierarchy). We want to keep components loosely coupled.

* **Avoiding Other Anti-Patterns**: The steering doc should list some known React anti-patterns to avoid, with preferred solutions:

* **Heavy computation or data transformation inside render**: If a component does expensive calculations or data manipulation each render, that’s an anti-pattern[\[17\]](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933#:~:text=6%20Common%20React%20Anti,Complicated%20Logic%20in). The fix is to do such work outside of render or memoize it. Our docs can say “Don’t compute derived data in the body of a component on each render – use useMemo or move it out.” Similarly, avoid performing side effects directly in rendering logic – use useEffect appropriately.

* **Large, God Components**: If a component handles too many responsibilities (logic \+ UI \+ state of many types), it becomes hard to maintain. Encourage splitting into Presentational and Container components (or just smaller components) – e.g., one component fetches data and only passes it to a pure presentational child. This pattern makes it easier to test and reason about each piece. Our design guidelines can encourage a **“smart vs dumb component”** separation when applicable, or at least modular breakdown.

* **Not handling cleanup in effects**: Warn that every effect that subscribes or schedules work (like event listeners, timers, async calls) should clean up after itself (using the cleanup function of useEffect or cancellation) to avoid memory leaks.

* **Using outdated patterns**: e.g., discourage use of legacy lifecycle methods or older patterns like using UNSAFE\_ methods, or overusing Higher-Order Components when hooks could do. We can explicitly mention: “Prefer hooks and composition to HOCs/render-props unless there’s a specific need. Hooks usually lead to simpler code.”

* **Keys in Lists**: A minor but common issue – remind that when rendering lists, use stable unique keys (not array indices) to prevent reconciliation bugs.

* **CSS and styling**: If relevant, note our approach (maybe CSS-in-JS or utility classes like Tailwind). The Telerik article notes the rise of utility-first CSS like Tailwind[\[18\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=match%20at%20L661%20The%20Rise,First%20CSS%20with%20Tailwind); if our project uses something similar, mention it so patterns stay consistent (e.g., “We use Tailwind for styling; avoid deeply nested CSS and leverage utility classes for consistency”).

In summary, the React section of the steering/design docs should outline **how we build components in 2025**: functional components, hooks for logic and state, context for global needs, and an eye towards composition and clarity. By also listing anti-patterns (prop drilling, overly complicated components, duplicating logic instead of extracting hooks, etc.[\[17\]](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933#:~:text=6%20Common%20React%20Anti,Complicated%20Logic%20in)) and their solutions, we set clear expectations for code quality on the front-end.

These patterns will make the front-end more scalable and maintainable. For example, using custom hooks for data fetching means if the mechanism changes (say we move from REST to GraphQL), we update one hook rather than dozens of components. Using context wisely means easier feature additions (e.g., a new component that needs global user info can just consume context). All this should be captured in the updated docs so the team is guided toward these best practices.

## Synchronizing Design & Tasks with the Updated Architecture

With the requirements, architecture, and steering docs updated as above, we should ensure the **design.md** and **tasks.md** are brought in sync as well. A consistent, top-down documentation flow is crucial[\[19\]](https://arc42.org/principles-of-technical-documentation#:~:text=Your%20audience%20shall%20be%20able,down): start from high-level requirements, drill down to architecture (L1 and L2), then to detailed design, and finally to implementation tasks. Each document should trace logically into the next:

* **requirements.md ➡️ architecture.md**: The architecture doc should clearly address the key requirements. After our updates, architecture.md will contain high-level structure and principles (like TDD approach, major Rust/React patterns to use). We should double-check that every major requirement (from requirements.md) is mapped to some architectural element or decision in architecture.md. For instance, if a requirement is low-latency messaging, architecture.md should note the system will use async Rust services to handle messaging, etc. The TDD approach in architecture.md also means that for each requirement, there will be corresponding tests (which effectively become part of the requirement verification). This linkage could be mentioned in design.md as well (like a traceability matrix or simply references from design back to requirements).

* **architecture.md ➡️ architecture-L2.md**: The level-2 architecture document is more detailed. After adding the TDD-driven interfaces and module breakdown, architecture-L2 should effectively be a realization of the high-level architecture. We should ensure it doesn’t contradict anything in architecture.md. If architecture.md says “we will have a module for X and it will handle Y”, then architecture-L2 should show how (e.g., listing the key functions, classes, or data flows in module X). The TDD influence means architecture-L2 might even include some pseudo-code of tests or example usage of those APIs – that’s okay, as it makes the design concrete. Keep architecture-L2 aligned by updating any diagrams or tables to reflect the Rust/React patterns: for example, if previously the design imagined a certain pattern that we now replaced with a better one, update that. (E.g., perhaps initially a singleton was planned for global state, but now we choose React Context; the architecture-L2 should be adjusted accordingly.)

* **architecture-L2.md ➡️ design.md**: The design document typically contains specifics on how to implement the architecture (maybe at a feature level or with more granular decisions). After our changes, design.md should incorporate the **TDD planning and patterns in actionable terms**. For instance, design.md can outline the plan for **each subsystem**: what tests will be written first, what the function signatures look like (perhaps referencing the architecture-L2 list), and how the internal logic will fulfill those contracts. It can also mention specific frameworks or libraries (like “using Tokio for async runtime” or “using React 19 features like Server Components if applicable”). Importantly, integrate the Rust/React best practices into design decisions. For example, design.md might have a section “Frontend Design Decisions” listing why we chose React Context for auth state, or “Backend Design Decisions” listing why we use trait abstraction for database layer – referencing the patterns described in the steering doc. This ensures consistency: the steering doc says *what* patterns to use, and design.md shows *where* we apply them.

* **design.md ➡️ tasks.md**: Finally, the tasks.md (which likely is a breakdown of actionable tasks or a roadmap) should reflect the updated approach. If we are doing TDD and one-shot design, tasks might need to be ordered a certain way. For example:

* First task might be “Draft test cases and function stubs for Feature A (no implementation yet)”.

* Second task: “Implement Feature A to make tests pass”.

* Similarly, tasks for creating custom hooks in the frontend, or setting up the context providers, etc., should be explicit. Because we want to enforce patterns, we could add tasks like “Refactor component X to use a custom hook Y for logic” if applying patterns to existing code.

* The tasks list should also capture any tech debt or follow-ups that our changes introduce (maybe “Audit code for any unwrap() and replace with Result handling” as a task, to enforce the anti-pattern avoidance).

Ensuring tasks align with design means each task should tie back to a design element or decision. One way to do this (if not already) is to label tasks with the feature or module name they belong to, which corresponds to sections in design.md. After our updates, we should review tasks.md and update any that are inconsistent. For example, if tasks.md had an item “Implement Singleton for App State”, but we decided to use Context API instead, that task should be changed to “Implement Context provider for App State”. Or if design.md now specifies writing tests first, tasks.md should include tasks like “Write tests for X” before “Code X”.

By doing this, we achieve a cohesive set of documentation: **requirements define the goals, architecture defines the high-level solution and principles (now including TDD and patterns), architecture-L2 details the solution’s structure (now including planned interfaces and TDD outline), design fleshes out how to build it with chosen patterns, and tasks list the steps to execute that design.** All documents are in sync and reflect our modern approach. This top-down alignment not only keeps the team focused and informed, but also follows best practices for technical documentation structure (overview to detail)[\[19\]](https://arc42.org/principles-of-technical-documentation#:~:text=Your%20audience%20shall%20be%20able,down). It will help new contributors understand *why* things are done a certain way (by reading steering/architecture reasoning) and *how* to do them (by following design and tasks).

## Conclusion

In summary, we recommend the following updates across the documents:

* **Architecture & Arch L2**: Embrace a TDD-driven design approach by specifying module interfaces and function signatures upfront, guided by test cases. Emphasize planning and writing tests as part of the design, to strive for a one-shot correct implementation. This section should reflect how writing tests first influences architecture (shaping cleaner APIs and clarifying requirements)[\[3\]](https://github.com/luizalabs/tutorial-python-brasil/blob/ce1959d57de1352ef2763ab26ec340b612196058/tdd.md#L43-L50)[\[4\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=In%20this%20approach%2C%20we%20start,I%20expect%20from%20the%20code).

* **Steering**: Integrate the TDD philosophy into development guidelines (tests-before-code, small iterations, interface reviews) and incorporate modern **Rust** and **React** best practices. The steering doc should clearly list the patterns we follow: e.g., “In Rust, use Result for errors, avoid panics[\[9\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Rust%E2%80%99s%20promise%20of%20performance%20and,to%20unlock%20Rust%E2%80%99s%20full%20potential), favor traits for extensibility; in React, use functional components with hooks[\[14\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Function%20Components%20as%20the%20Standard), leverage custom hooks[\[15\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Custom%20Hooks%20for%20Logic%20Reusability), avoid prop drilling[\[17\]](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933#:~:text=6%20Common%20React%20Anti,Complicated%20Logic%20in),” and so on. This creates a shared understanding of the technical approach.

* **Design**: Update the design document to apply those patterns in detail. Wherever a pattern or principle is mentioned in steering, the design doc should show it in action for our project. It should also be updated to ensure any design element (UI component hierarchy, data flow, etc.) is consistent with the new architecture decisions (for example, if using Context API, detail what contexts we’ll have and their providers/consumers).

* **Tasks**: Reorder or modify tasks to align with the TDD-first workflow and the chosen patterns. Include tasks for writing tests and designing signatures, and tasks for implementing features following those tests. Add tasks for refactoring any existing code that doesn’t meet the new patterns (if applicable), such as removing anti-patterns (e.g., replace any leftover React class components or eliminate unwrap() calls in Rust code).

By performing these updates, all documentation levels – from high-level requirements down to daily task tracking – will be **in sync and mutually reinforcing**. This ensures the project is guided by a clear, modern vision: one that uses TDD to drive design and leverages the best of Rust and React in 2025 to build a robust Campfire application. Each document will seamlessly feed into the next (requirements → architecture → design → implementation plan), providing clarity and confidence that the team is building the right thing in the right way.

---

[\[1\]](https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined#:~:text=TDD) [\[2\]](https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined#:~:text=It%27s%20true%20that%20in%20order,sense%2C%20conceptual%20design%20%27comes%20first) testing \- In TDD, how do you write tests first when the functions to test are undefined? \- Stack Overflow

[https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined](https://stackoverflow.com/questions/66684057/in-tdd-how-do-you-write-tests-first-when-the-functions-to-test-are-undefined)

[\[3\]](https://github.com/luizalabs/tutorial-python-brasil/blob/ce1959d57de1352ef2763ab26ec340b612196058/tdd.md#L43-L50) tdd.md

[https://github.com/luizalabs/tutorial-python-brasil/blob/ce1959d57de1352ef2763ab26ec340b612196058/tdd.md](https://github.com/luizalabs/tutorial-python-brasil/blob/ce1959d57de1352ef2763ab26ec340b612196058/tdd.md)

[\[4\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=In%20this%20approach%2C%20we%20start,I%20expect%20from%20the%20code) [\[5\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=The%20requirements%20may%20be%20something,like) [\[7\]](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design#:~:text=TDD%20is%20an%20iterative%20approach,adapting%20itself%20to%20its%20tests)  Test Driven Development is the best thing that has happened to software design | Thoughtworks United States 

[https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design](https://www.thoughtworks.com/en-us/insights/blog/test-driven-development-best-thing-has-happened-software-design)

[\[6\]](https://www.reddit.com/r/golang/comments/17ubh56/tdd_i_keep_doing_implementation_first_rather/#:~:text=You%20don%27t%20need%20to%20write,That%27s%20how%20TDD%20goes) \[TDD\] I keep doing implementation first rather writing Tests first. : r/golang

[https://www.reddit.com/r/golang/comments/17ubh56/tdd\_i\_keep\_doing\_implementation\_first\_rather/](https://www.reddit.com/r/golang/comments/17ubh56/tdd_i_keep_doing_implementation_first_rather/)

[\[8\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Anti,Addiction) [\[9\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Rust%E2%80%99s%20promise%20of%20performance%20and,to%20unlock%20Rust%E2%80%99s%20full%20potential) [\[10\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=Takeaway%3A%20Embrace%20,simplify%20error%20handling) [\[11\]](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54#:~:text=1.%20Handle%20CPU,spawn_blocking) The 7 Rust Anti-Patterns That Are Secretly Killing Your Performance (and How to Fix Them in 2025\!) | by Sreeved Vp | solo devs | Medium

[https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54](https://medium.com/solo-devs/the-7-rust-anti-patterns-that-are-secretly-killing-your-performance-and-how-to-fix-them-in-2025-dcebfdef7b54)

[\[12\]](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba#:~:text=1) [\[13\]](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba#:~:text=When%20most%20people%20talk%20about,with%20something%20simpler%20and%20safer) Design Patterns in Rust That Will Change How You Architect Software | by Harishsingh | Jul, 2025 | Medium

[https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba](https://medium.com/@harishsingh8529/design-patterns-in-rust-that-will-change-how-you-architect-software-a6d39930a4ba)

[\[14\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Function%20Components%20as%20the%20Standard) [\[15\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Custom%20Hooks%20for%20Logic%20Reusability) [\[16\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=Context%20API%20for%20Application) [\[18\]](https://www.telerik.com/blogs/react-design-patterns-best-practices#:~:text=match%20at%20L661%20The%20Rise,First%20CSS%20with%20Tailwind)  React Design Patterns and Best Practices for 2025 

[https://www.telerik.com/blogs/react-design-patterns-best-practices](https://www.telerik.com/blogs/react-design-patterns-best-practices)

[\[17\]](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933#:~:text=6%20Common%20React%20Anti,Complicated%20Logic%20in) 6 Common React Anti-Patterns That Are Hurting Your Code Quality

[https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933](https://itnext.io/6-common-react-anti-patterns-that-are-hurting-your-code-quality-904b9c32e933)

[\[19\]](https://arc42.org/principles-of-technical-documentation#:~:text=Your%20audience%20shall%20be%20able,down) Principles of technical documentation \- arc42

[https://arc42.org/principles-of-technical-documentation](https://arc42.org/principles-of-technical-documentation)